<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
<head>
    <title>JSCover - Documentation</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
<div class="container">
    <h1>JSCover</h1>

    <div>
        <a class="nav" href="index.html">Home</a>
        <span class="nav selected">Documentation</span>
        <a class="nav" href="links.html">Links</a>
        <a class="nav" href="license.html">License</a>
    </div>

    <h2>JSCover Server</h2>

    <p>
        For an overview of the basic workings of of JSCover, see the
        <a href="http://siliconforks.com/jscoverage/manual.html">JSCoverage documentation</a>. JSCover currently
        supports the same features JSCoverage including:
    </p>

    <ul>
        <li>Server mode with switches indicated below</li>
        <li>Storing of report data to the file system</li>
        <li>Merging of coverage data if multiple runs are stored at the same location</li>
    </ul>

    <p>
        NB - The binary <i>JSCover.jar</i> must have all dependent JARs available in the same directory.
        Currently only the server is implemented with the following usage:
    </p>

    <div class="shell">
        java -jar JSCover.jar [OPTION]...
    </div>

    <p>For example</p>

    <div class="shell">
        java -jar JSCover.jar --port=80 --no-instrument=/lib --no-instrument=/test
    </div>

    <p>
        Run example.sh (see below) and then go to
        <a href="http://localhost:8080/jscoverage.html?/">http://localhost:8080/jscoverage.html?/</a>.
    </p>

    <div class="shell">
        java -jar target/dist/JSCover.jar --document-root=doc/example --report-dir=target
    </div>
    <p>Command line options are:</p>
    <table>
        <tr>
            <th>Option</th>
            <th>Default</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>-h,--help</td>
            <td>N/A</td>
            <td>Display command line help</td>
        </tr>
        <tr>
            <td>--document-root=PATH</td>
            <td>current directory</td>
            <td>Serve web content from the directory given by PATH (can be relative or absolute)</td>
        </tr>
        <tr>
            <td>--no-instrument=URL</td>
            <td>None</td>
            <td>Specify URLs not to be instrumented. Can be specified multiple times.</td>
        </tr>
        <tr>
            <td>--report-dir=PATH</td>
            <td>current directory</td>
            <td>Use the directory given by PATH (can be relative or absolute) for storing coverage reports.</td>
        </tr>
        <tr>
            <td>--port=PORT</td>
            <td>8080</td>
            <td>Specify the port to listen on</td>
        </tr>
        <tr>
            <td>--js-version=VERSION</td>
            <td>1.3</td>
            <td>Use the specified JavaScript version; valid values for VERSION are 1.0, 1.1, 1.2, ..., 1.8.</td>
        </tr>
    </table>
    <p>
        The server can be stopped by issuing a request to the URI '/stop' on the server (e.g.
        http://localhost:8080/stop)
    </p>

    <p>
        A log file is also produced in the report directory which should be inspected after running.
        It will contain any errors that occurred during instrumentation.
    </p>

    <h2>JSCover Versus JSCoverage</h2>

    <p>
        The main difference in the implementation is the tools used for parsing.
        All JavaScript code is the same, and so the UI interaction is the same.
    </p>
    <table>
        <tr>
            <th>Tool</th>
            <th>Parser Language</th>
            <th>Parser Implementation</th>
        </tr>
        <tr>
            <td>JSCover</td>
            <td>Java</td>
            <td><a href="http://www.mozilla.org/rhino/">Rhino</a> 1.7R4</td>
        </tr>
        <tr>
            <td>JSCoverage</td>
            <td>C/C++</td>
            <td><a href="https://developer.mozilla.org/en/SpiderMonkey">SpiderMonkey</a></td>
        </tr>
    </table>
    <p>
        As SpiderMonkey is used in FireFox which is used for much development and testing of web-based JavaScript, it is
        arguably the best JavaScript implementation currently available.
    </p>


    <a name="future"></a>

    <h2>Future</h2>

    <ul>
        <li>
            Making the project available in Java opens up a huge community who
            can contribute
        </li>
        <li>
            Hopefully a side-effect of this project is to expose Rhino to a much greater set of JavaScript,
            thus improving it's quality. This project has already contributed directly and indirectly to
            several AST bugs being corrected.
        </li>
        <li>
            The Java implementation and modularity can leverage existing tools:
            <ul>
                <li>An example is using NanoHTTPD as the web-server</li>
                <li>The JavaScript syntax highlighting implementation can using existing libraries</li>
                <li>The JavaScript JSON parsing can using Rhino</li>
                <li>
                    The coverage report can use existing libraries (e.g.
                    <a href="http://cobertura.sourceforge.net/">Cobertura</a> or lcov)
                </li>
            </ul>
        </li>
    </ul>

    <a name="todo"></a>

    <h2>To-Do</h2>
    <p>
        In order of priority unless feedback or other circumstances dictates otherswise:
    </p>
    <ul>
        <li>
            100% ECMAScript support (see @Ignore tests in
            <a href="../src/test/jscover/instrument/InstrumentAndHighlightRegressionTest.java">InstrumentAndHighlightRegressionTest</a>)
        </li>
        <li>Add branch coverage</li>
        <li>Add client mode to generate instrumented JavaScript code</li>
        <li>More documentation and examples</li>
        <li>Improve tests and coverage</li>
        <li>Tidy logic in ParseTreeInstrumenter</li>
        <li>Send NanoHTTPD patch for JSON data submission</li>
        <li>Send NanoHTTPD patch for stopping the server via a HTTP request</li>
        <li>Add in check-style</li>
    </ul>

    <p>&nbsp;</p>
</div>
</body>
</html>